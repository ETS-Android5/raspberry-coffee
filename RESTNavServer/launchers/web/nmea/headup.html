<!DOCTYPE html>
<!--
   100% Self contained:
   no external libraries,
   no script imports.
 +-->
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Head-Up Display</title>
	<link rel="icon" type="image/ico" href="../icons/hammerhead.02.ico">
</head>
<style>

	:root {
		--perspective: 50em;
		--rotateX: -50deg;
	}

	body {
		color: yellow;
		background-color: black;
		font-family: "Helvetica Neue", "Lato", Verdana, Helvetica, Geneva, sans-serif;
	}

	.mirror-upside-down {
		display: block;
		-webkit-transform: matrix(-1, 0, 0, 1, 0, 0) rotate(180deg) perspective(var(--perspective)) rotateX(var(--rotateX));
		-moz-transform: matrix(-1, 0, 0, 1, 0, 0) rotate(180deg) perspective(var(--perspective)) rotateX(var(--rotateX));
		-o-transform: matrix(-1, 0, 0, 1, 0, 0) rotate(180deg) perspective(var(--perspective)) rotateX(var(--rotateX));
		transform: matrix(-1, 0, 0, 1, 0, 0) rotate(180deg) perspective(var(--perspective)) rotateX(var(--rotateX));
	}

	.big {
		font-size: 96px;
	}
</style>
<body>
<div id="the-div" class="mirror-upside-down big" style="padding: 0px; text-align: center;">

	<div id="one" style="display: block;">
		<table style="margin: auto; border: 1px solid silver;">
			<tr>
				<td colspan="1">Position</td>
			</tr>
			<tr>
				<td valign="top">
					<span id="latitude">N 37° 44.93'</span>
					<br/>
					<span id="longitude">W 122° 30.42'</span>
				</td>
			</tr>
		</table>
	</div>

	<div id="two" style="display: none;">
		<table style="margin: auto; border: 1px solid silver;">
			<tr>
				<td colspan="1">Speed</td>
			</tr>
				<td valign="top">
					<span id="speed">12.34 kts</span>
				</td>
			</tr>
		</table>
	</div>

	<div id="three" style="display: none;">
		<table style="margin: auto; border: 1px solid silver;">
			<tr>
				<td colspan="1">Heading</td>
			</tr>
			<td valign="top">
				<span id="heading">000°</span>
			</td>
			</tr>
		</table>
	</div>

</div>
</body>
<script type="text/javascript">
	/**
	 Subscribe like this:
	 events.subscribe('topic', (val) => {
     doSomethingSmart(val);
   });

	 Publish like that:
	 events.publish('topic', val);

	 Don't use arrow functions in the members below (ok when subscribing though, see the comment above).
	 */
	let events = {
		listener: [],

		subscribe: function (topic, action) {
			this.listener.push({
				'topic': topic,
				'actionListener': action
			});
		},

		publish: function (topic, value) {
			for (let i = 0; i < this.listener.length; i++) {
				if (this.listener[i].topic === topic) {
					this.listener[i].actionListener(value);
				}
			}
		}
	};

	events.subscribe('pos', function(val) {
		let latField = document.getElementById("latitude");
		let lngField = document.getElementById("longitude");
		latField.innerText = decToSex(val.lat, "NS");
		lngField.innerText = decToSex(val.lng, "EW");
	});

	events.subscribe('sog', function(val) {
		let speedField = document.getElementById("speed");
		speedField.innerText = val.toFixed(2) + " kts";
	});

	events.subscribe('cog', function(val) {
		let speedField = document.getElementById("heading");
		speedField.innerText = val.toFixed(0) + "°";
	});

	function decToSex(val, ns_ew) {
		let absVal = Math.abs(val);
		let intValue = Math.floor(absVal);
		let dec = absVal - intValue;
		dec *= 60;
		let s = "";
		if (val < 0) {
			s += (ns_ew === 'NS' ? 'S' : 'W');
		} else {
			s += (ns_ew === 'NS' ? 'N' : 'E');
		}
		s += " ";
		s += intValue + "°" + dec.toFixed(2) + "'";
//  s = intValue + String.fromCharCode(176) + dec.toFixed(2) + "'";
		return s;
	}

	const DEFAULT_TIMEOUT = 60000; // 1 minute
	function getPromise(
			url, // full api path
			timeout, // After that, fail.
			verb, // GET, PUT, DELETE, POST, etc
			headers, // Request headers
			happyCode, // if met, resolve, otherwise fail.
			data = null) { // payload, when needed (PUT, POST...)

		let promise = new Promise(function(resolve, reject) {
			let xhr = new XMLHttpRequest();

			// let req = verb + ' ' + url;
			// if (data !== undefined && data !== null) {
			// 	req += ("\n" + JSON.stringify(data)); // , null, 2));
			// }

			xhr.open(verb, url, true);
			if (headers !== undefined) {
				headers.forEach(header => {
					xhr.setRequestHeader(header.name, header.value);
				});
			}
			try {
				if (data === undefined || data === null) {
					xhr.send();
				} else {
					xhr.send(JSON.stringify(data));
				}
			} catch (err) {
				console.log('Send Error ', err);
			}

			var requestTimer;
			if (timeout !== undefined) {
				requestTimer = setTimeout(function() {
					xhr.abort();
					let mess = {
						code: 408,
						message: 'Timeout',
						url: url,
						verb: verb
					};
					reject({
						err: mess,
						accessToken: xhr.getResponseHeader('Access-Token')
					});
				}, timeout);
			}

			xhr.onload = function() {
				if (requestTimer !== undefined) {
					clearTimeout(requestTimer);
				}
				if ((Array.isArray(happyCode) && happyCode.includes(xhr.status)) || xhr.status === happyCode) {
					resolve({
						response: xhr.response,
						accessToken: xhr.getResponseHeader('Access-Token')
					});
				} else {
					reject({
						code: xhr.status,
						message: xhr.response,
						accessToken: xhr.getResponseHeader('Access-Token')
					});
				}
			};
		});
		return promise;
	}

	let displayErr = console.error;

	function onMessage(json) {
		try {
			var errMess = "";

			try {
				let latitude = json.Position.lat;
//          console.log("latitude:" + latitude)
				let longitude = json.Position.lng;
//          console.log("Pt:" + latitude + ", " + longitude);
				events.publish('pos', {
					'lat': latitude,
					'lng': longitude
				});
			} catch (err) {
				errMess += ((errMess.length > 0 ? ", " : "Cannot read ") + "position");
			}

			try {
				let sog = 0;
				if (json.SOG !== undefined) {
					sog = json.SOG.speed;
				}
				events.publish('sog', sog);
			} catch (err) {
				errMess += ((errMess.length > 0 ? ", " : "Cannot read ") + "boat speed");
			}

			try {
				let cog = 0;
				if (json.COG !== undefined) {
					cog = json.COG.angle;
				}
				events.publish('cog', cog);
			} catch (err) {
				errMess += ((errMess.length > 0 ? ", " : "Cannot read ") + "boat speed");
			}

			if (errMess.length > 0) {
				displayErr(errMess);
			}
		} catch (error) {
			displayErr(error);
		}
	}

	function fetch() {
		let headers = [ {name: 'Accept', value: 'application/json'}];
		let getData = getPromise("/mux/cache", DEFAULT_TIMEOUT, "GET", headers, [200, 201]);
		getData.then((value) => {
//    console.log("Done:", value);
			try {
				if (value.response.length > 0) {
					let json = JSON.parse(value.response);
					onMessage(json);
				} else {
					console.log('Empty response');
				}
			} catch (error) {
				console.error('For data', value);
				console.error(error);
			}
		}, (error, errmess) => {
			let message = "";
			if (errmess !== undefined) {
				let mess = JSON.parse(errmess);
				if (mess.message !== undefined) {
					message += mess.message;
				}
			}
			alert("Failed to get nmea data..." + (error !== undefined ? (typeof(error) === 'object' ? JSON.stringify(error, null, 2) : error.toString()) : ' - ') + ', ' + (message.length > 0 ? message : ' - '));
		});
	}

	let tabs = [ 'one', 'two', 'three' ];
	let dataIndex = -1;
	function scroll(ms) {
		dataIndex += 1;
		dataIndex %= tabs.length; // in [ 0, tabs.length [
		// console.log('Displaying tab %d', dataIndex)
		for (let idx=0; idx<tabs.length; idx++) {
			document.getElementById(tabs[idx]).style.display = (idx === dataIndex ? 'block' : 'none');
		}
		setTimeout(function() {
			scroll(ms);
		}, ms);
	}

	(() => {
		// console.log("Let's go!");
		let intervalOne = setInterval(function () {
			fetch();
		}, 1000);
		scroll(5000);
	})();

</script>
</html>
